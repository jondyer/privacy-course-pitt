\documentclass{article}
\author{Jonathan Dyer}
\title{CS 1699: Privacy in the Electronic Society \\
        \textit{Project 2 -- Access Control Policies}}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage[margin=0.8in]{geometry}
\usepackage{graphicx}
\usepackage[backend=bibtex,type=alphabetical,sorting=ynt]{biblatex}
\addbibresource{p2.bib}

\usepackage{sectsty}
\subsubsectionfont{\normalfont\itshape}

% ============ USED FOR MY FORMAT ============
\providecommand{\task}[1]{\section{Task #1}}
\providecommand{\image}[1]{
    \begin{center}
        \includegraphics[width=1.0\textwidth]
            {#1}
    \end{center}
}
\providecommand{\tightlist}{
    \setlength{\itemsep}{1pt}\setlength{\parskip}{0pt}
}
\providecommand{\inlinecode}{\texttt}
\providecommand{\RT}{\textbf{RT}}

% ============ USED FOR CODE LISTINGS ============
\usepackage{listings}
\usepackage[usenames,dvipsnames,svgnames]{xcolor}
\definecolor{javagreen}{rgb}{0.25,0.5,0.35}
\lstdefinelanguage{XML}
{
  basicstyle=\ttfamily\footnotesize,
  morestring=[b]",
  moredelim=[s][\bfseries\color{Maroon}]{<}{\ },
  moredelim=[s][\bfseries\color{Maroon}]{</}{>},
  moredelim=[l][\bfseries\color{Maroon}]{/>},
  moredelim=[l][\bfseries\color{Maroon}]{>},
  morecomment=[s]{<?}{?>},
  morecomment=[s]{<!--}{-->},
  commentstyle=\color{DarkOliveGreen},
  stringstyle=\color{blue},
  identifierstyle=\color{red}
}

\lstset{
  frame               = single,
  language            = XML,
  numbers             = left,
  showstringspaces    = false,
  keywordstyle        = \color{blue},
  mathescape
}

\setcounter{secnumdepth}{0} % sections are level 1


\begin{document}
\maketitle

\tableofcontents

\pagebreak

\task{W0}
\subsection{$\RT_0$: Role-based Trust management with attributes}
The access-control language selected for this project is a simplified variant of a family of expressive languages known as $\RT$, which is short for \textit{\textbf{R}ole-based \textbf{T}rust-management}.
In spite of the name, the $\RT$ family is actually an extension of role-based access control (RBAC) known as \textit{attribute}-based access control (ABAC).
It fulfills all of the desirable traits mentioned in \cite{RTmain}, including delegation of attribute authority, inference of attributes, and more.
By allowing explicit subject abstraction and specific attribute assignment to those subjects, the system provides the same functionality that roles do via selection by attributes and intersection of attributes along with even greater flexibility and expressiveness.
The language utilized here is based on a combination of $\RT_0$ and $\RT_2$, and functions as follows:
\begin{itemize}
  \item The primary structures in this framework are \textit{entities} (or principals), \textit{subjects} (or users), \textit{roles} (which contain rights or permissions), and \textit{objects} (or resources).
  \item \textbf{Entities} are simply the organizations or systems that issue credentials (i.e. assign roles to users). By explicitly abstracting entities, the $\RT$ framework allows for localized roles, as well as more extensive delegation.
  \item \textbf{Subjects} are the users or agents in the system. They may have one or more roles that provide them with permissions (or authorized actions) for accessing objects in the specified way.
  \item \textbf{Roles} are a convenient way of grouping permissions that may be assigned to subjects. Roles may be hierarchical--if one role dominates another, then it has every permission the other role has. This helps reduce the number of roles and relationships that have to be dealt with in the system. Role assignment may be achieved by specifying subject attributes.
  \item \textbf{Objects} are the elements whose access is being controlled by this entire schema. They may be grouped by attribute as well, allowing flexible and powerful specification of permissions.
  \item Each structure accepts descriptive \textit{attributes} that enable powerful specification of policies based on any desired combination of subject, role, or object attributes. This, in conjunction with the outline above, facilitates the following features (among others):
  \begin{enumerate}
    \item \textbf{Indirection}: Because we can specify policies according to attributes, we may assign i) a set of permissions (i.e. a role or multiple roles), to ii) a set of users, over iii) a set of objects, as long as those sets can be well-defined or uniquely specified (i.e. all elements in the desired set must share an attribute that specifies exactly that set).
    \item \textbf{Delegation}: Different entities that assign roles (within their domain) may easily defer to the authority of another entity for checking role membership. That is to say, if organization $A$ defines role $r_1$, it is simple to write a policy that includes into $r_1$ all members of role $r_2$ from some other organization $B$ as well. This is also referred to as 'delegation of attribute authority', meaning that if $B$ says that some subject has attribute $r_2$, then $A$ says it has attribute $r_1$ (here speaking of roles as attributes of users). Details of how this is done are given in the next section.
    \item \textbf{Role Hierarchy}: Roles may inherit permissions from other roles given by the same entity. This is a variant of delegation, in a sense allowing an organization to delegate authority over some role attribute to that same organization under another role attribute. Thus, role management is simplified and duplication is reduced.
    \item \textbf{Logical Objects}: Inspired by $\RT_2$, the current variation of this framework also supports collections of objects, known as Object Groups, which allows addition by attribute and assignment of permissions respecting objects \textit{en masse}. In other words, it is possible to define a role with an access mode and an entire group of logically-related objects (via attributes) rather than just one object at a time.
    \item \textbf{Attribute Inference}: The $\RT$ framework is flexible enough to allow specification of inference rules. This essentially provides a conditional ('if-then') logic that allows you to assert some property of a subject, object, or role as long as it has some other property.
    \item \textbf{Attribute Intersection}: Support of multiple attributes on any given element in the system also allows specification of policies by intersection of attributes. For instance, it is possible to specify an action that is allowed only for users who are in the intersection of multiple roles (i.e. users that have each of those roles). This feature is \textbf{not implemented} in the current project.
  \end{enumerate}
\end{itemize}
It is important to note that there are many other extensions and variations in the $\RT$ language family, and the current iteration was chosen as a convenient balance between expressiveness and feasibility for the purposes of the current project. Many other features are possible within the $\RT$ framework, such as parameterization of attributes, threshold policies, and more. \par
Further, it is important to note that the original specification of $\RT$ also included details regarding the issue of \textit{common vocabularies} across entities. This issue of vocabularies or namespaces is dealt with via \textit{application domain specification documents (ADSDs)}, but was ommitted here for brevity's sake, and because it is not relevant to the ideas being explored. For more information however, and generally for a great amount of detail regarding the $\RT$ family of languages, see \cite{RTmain} and \cite{RTold}.


\task{W1}
\subsection{Overview of Syntax and Policy File Format}
The syntax chosen to write policy files for the above language is straightforward and designed for maximal ease and clarity. It is encoded in XML, and comprises two primary sections in every entity for which policies are being defined: 1) Data, and 2) Policies.
\paragraph{Data} is where all elements of the entity are (uniquely!) specified, and includes the following:
\begin{itemize}\tightlist
  \item A full definition of any objects in the entity, including Logical Objects (object groups) and any attributes associated with them.
  \item A definition of all roles and their corresponding permissions, including all objects/object groups those roles affect. Any role hierarchy will be defined in the policy section.
  \item Specification of all subjects or users given credentials (i.e. assigned roles) in the entity.
\end{itemize}
\paragraph{Policies} is the section where any of the extra features or relationships are defined. Although many of the basic access policies are implicitly encoded in the Data section, more advanced relationships are expressed here, including:
\begin{itemize}\tightlist
  \item Delegation of authority.
  \item Role hierarchy definition.
  \item Access that relies on attribute intersection (not discussed in this document).
  \item Attribute inference or other complex relationships.
\end{itemize}

Thus an overall outline of the policy file may look like this:
\begin{lstlisting}
<?xml version="1.0"?>
<!-- The <root> element simply contains everything and exists for parsing convenience -->
<root>
    <entity name="Entity 1">
        <data>
            <objects>
              ...       <!-- All object groups and resources go here -->
            </objects>
            <roles>
              ...       <!-- All roles and permissions go here -->
            </roles>
            <subects>
              ...       <!-- All subjects and their attributes go here -->
            </subjects>
        </data>
        <policies>
          ...           <!-- All specific policies go here -->
        </policies>
    </entity>
    <entity name="Entity 2">
      ...               <!-- Repeat for as many entities as you're defining -->
    </entity>
</root>
\end{lstlisting}

In keeping with generally accepted XML style, all core and necessary features of an element are contained in sub-elements, while optional or incidental data, including labels (i.e. attributes) are contained as XML attributes in the opening tag. \par

It is important to keep in mind that the description here is for a basic outline of a policy file, including implementation of features 1-5 above. Further extensions and options are possible and may be made available at a later time, but this describes the minimum syntax necessary to write an access control policy file with these features in $\RT$ using an XML encoding.

\paragraph{Note:} Throughout this document the term "administrator" will be used to refer to the writer of the policy file. Additionally, it is \textit{imperative} that the names of all objects, groups, roles, and subjects \textit{within an entity} be considered unique identifiers and not coincide, except with structures belonging to another entity.


\subsubsection{Entities}
The only thing to know about the \inlinecode{<entity>} element is that it has a single attribute called 'name' by which you may indicate the name of the entity. In order to utilize delegation, relevant entities \textit{must} be named, and uniquely. Note that this implementation does not currently support hierarchical entities. Otherwise, each section (Data + Policies) necessary for an entity's fully-described access control is explained forthwith.

\subsection{Data}
The \inlinecode{<data>} tag has no attributes, so we will move directly into considering objects, roles, and subjects.

\subsubsection{Objects}
This section is straightworward to write: simply define any objects in your system, and assign them to groups if desired.
The \inlinecode{<objects>} tag itself takes no attributes, but rather serves to enclose the section. Two types of elements can be contained in this section:
\begin{enumerate}\tightlist
  \item Object Groups are denoted by the \inlinecode{<objectGroup>} tag and must have a name, and otherwise have no requirements.
  \item Individual objects, denoted by the \inlinecode{<object>} tag, must have a name and otherwise have no requirements. They may also be assigned to one or more groups, specified as sub-elements with \inlinecode{<group>}.
\end{enumerate}

Our first feature is introduced in this section, namely \textit{Logical Objects} (called 'Object Groups' from now on).
This refers to the ability to specify objects in one of two ways: individually by name, or as a collection via a formalized Object Group such as 'Files' or 'Printers'.
Here I give an example of how to represent both in the XML encoding schema.
Usage of (1) and (2) in access policies is covered in \textit{Roles}.
Detailed examples of Logical Objects will be provided later on in section \textbf{W5}.

The snippet of code below shows one Object Group called 'Files' and three objects, two of which are assigned the Files group and one of which is not assigned any group.
\begin{lstlisting}
...
<objects>
    <objectGroup description="This group is for regular old files">
        <name>Files</name>
    </objectGroup>
    <object description="This object is in the group 'Files'">
        <name>users_file.txt</name>
        <group>Files</group>
    </object>
    <object description="This object is also in the group 'Files'">
        <group>Files</group>
        <name>passwords_file.txt</name>
    </object>
    <object description="This object has no group">
        <name>LabPrinter</name>
    </object>
</objects>
...
\end{lstlisting}
\begin{itemize}\tightlist
  \item Note that each object or Object Group may have one or more attributes given in the opening tag (such as 'description'). These are optional and defined by the administrator, and are not used in the current implementation of $\RT$ but may be supported in some forthcoming feature (such as printing descriptions of structures in the policy file). They do not affect functionality and may be safely ignored.
  \item Significantly, we may assign an object to as many groups as we wish. In future releases, this would make possible the specification of objects by union/intersection of Object Groups, in what is known as 'Attribute Intersection'.
  \item Finally notice that order of sub-elements does not matter -- \inlinecode{group} may come before or after \inlinecode{name}.
\end{itemize}

\subsubsection{Roles}
The roles section is only slightly more complex, since all advanced role manipulation takes place in the Policies section. Of special note below, we \textit{must} designate a name for every role, else it will not be useful. The \inlinecode{<objects>} tag itself requires no attributes. \par
Also, because the \textit{types} of access or permission tend to be far fewer than the number of objects being accessed, we will always define permissions according to type, followed by a list of objects that permission applies to, rather than entering every object and associated permissions individually. This saves a great deal of effort on the part of the administrator. \par
Our next feature, \textit{Indirection}, is best noted here, since it has primarily to do with assigning sets of permissions. These sets are abstracted as roles, and make it easy to lump permissions that are commonly assigned together.

\begin{lstlisting}
...
<roles>
    <role description="Everyone gets put into this role">
        <name>User</name>
        <permission description="Read rights for all Users">
            <type>Read</type>
            <target type="object">users_file.txt</target>
        </permission>
        <permission>
            <type>Write</type>
            <target type="object">users_file.txt</target>
        </permission>
    </role>             <!-- End role 'Member' -->
    <role description="This is only for superusers">
        <name>Admin</name>
        <permission description="Read all Files and objects for Admins">
            <type>Read</type>
            <target type="objectGroup">Files</target>   <!-- I can assign a group at once -->
            <target type="object">LabPrinter</target>   <!-- or just a single object -->
        </permission>
        <permission description="Write to all Files and objects for Admins">
            <type>Write</type>
            <target type="objectGroup">Files</target>
            <target type="object">LabPrinter</target>
        </permission>
    </role>             <!-- End role 'Admin' -->
</roles>
...
\end{lstlisting}
\begin{itemize}\tightlist
  \item All permissions must be described within the context of some role, and roles can have as many permissions as desired.
  \item The tag \inlinecode{<target>} defines what resource(s) the permission is referring to, and a given right may be assigned for an indefinite number of targets.
  \item The '\inlinecode{type=}' attribute is mandatory metadata that specifies the type of target being accessed; currently only objects and Object Groups are supported.
\end{itemize}


\subsubsection{Subjects}
The subjects section is the final sub-section of \textbf{Data}, and contains information about all users or actors in the system. Here they are assigned roles which give them the permissions associated with those roles.
This also supports \textit{Indirection}, by allowing users to be associated with a large set of permissions at once (in the form of a role), perhaps even pertaining to a large set of objects at once (in the form of Object Groups)! \par
Of note below is that every subject \textit{must} have a name, but not every subject must have a role (although users without a role will have no permissions, it is possible that such a circumstance is necessary). Otherwise this section is written in a natural and simple way. \par
The \inlinecode{<subjects>} tag itself requires no attributes, but simply encloses the section. \par

This section of code shows the user 'Alice' being defined and assigned the role 'Admin'.
\begin{lstlisting}
...
<subjects>
    <subject>
        <name>Alice</name>
        <role>Admin</role>
    </subject>
</subjects>
...
\end{lstlisting}

\subsection{Policies}
Now for the section on writing more advanced rules. Most policies can be written into the \textbf{Data} section above.
Each feature that has not already been covered -- \textit{Delegation, Role Hierarchy,} and \textit{Attribute Inference} -- is briefly presented here, and all features will receive in-depth treatment in sections \textbf{W3} through \textbf{W5}. \par
The \inlinecode{<policies>} tag requires no attributes, and there can be as few or as many sub-elements as desired.

\subsubsection{Hierarchy}
This is the simplest policy to define, and takes the form of an 'if-then' statement. All role hierarchies can be described this way: "\textit{If} some user has the role $r_1$, \textit{then} that user also has the role $r_2$". This is another way of saying that "Role $r_1$ \textit{dominates} role $r_2$". The format is simple:
\begin{lstlisting}
...
<policies>
    ...
    <hierarchy>
        <if>Role_1</if>
        <then>Role_2</then>
    </hierarchy>
    ...
</policies>
\end{lstlisting}
This will become useful for specifying specialized roles without repeating a lot of work. See \textbf{W5} for more details.

\subsubsection{Delegation}
Delegation is straightforward as well, although it requires more thought in order to write a useful policy. In $\RT$, because all access rights are assigned via roles, delegation takes the form of "Give some subject a role in one entity as long as it has some role in this other entity".
Again policy may take the form of a conditional: "\textit{If} some user has the role $r_1$ in entity $e_1$, \textit{then} that user also has the role $r_2$ in entity $e_2$".
Note that if the roles $r_1$ and $r_2$ are the same role $r$, then this becomes a delegation from $e_2$ to $e_1$ of authority over $r$. Conversely if the entities are the same entity $e$, then this becomes a case of role hierarchy.

\begin{lstlisting}
...
<policies>
    ...
    <delegation>
        <if>Role_1</if>         <!-- if this role   -->
        <from>Entity_1</from>   <!-- in this entity -->
        <then>Role_2</then>     <!-- then this role -->
        <to>Entity_2</to>       <!-- in this entity -->
    </delegation>
    ...
</policies>
\end{lstlisting}
The order of the elements is not important, but the presentation above may provide the best readability. Note that the \inlinecode{<to>} value must be the entity within which the policy is defined. See \textbf{W4} for more details.

\subsubsection{Inference}
Finally the attribute inference policy. As the only structures that currently support attributes are objects (in the form of Object Groups), this policy will have a fairly straightforward syntax as well, also in the form of a conditional: "\textit{If} some object is in group $g_1$, \textit{then} that object is also in the group $g_2$". See the following snippet for the structure.
\begin{lstlisting}
...
<policies>
    ...
    <inference>
        <if>Group_1</if>
        <then>Group_2</then>
    </inference>
    ...
</policies>
\end{lstlisting}
Essentially what we have described here is a type of Object Group Hierarchy, which allows inference of membership in one group to membership in another, thus the syntax is identical to the role hierarchy policies. More detailed examples are found in section \textbf{W5}.

\task{C2}
See the accompanying program \inlinecode{parser.py} for full details of the enforcement engine. It provides responses to standard access queries to answer the question "Can user $u$ access file $f$ with privilege $p$?" It also allows greater exploration of the consequences of the specified access policy file, all via a convenient interactive menu. This enables someone to discover which subjects have which roles in an entity, or what the permissions of each role are, answering such questions as "Is user $u$ a member of role $r$?" or "Can role $r$ access file $f$ with privilege $p$?" or even "Does entity $e$ have a role $r$?"

\task{W3}
\subsection{Indirection}
Here we provide more detailed and thorough examples of the indirection feature.
As previously mentioned, indirection refers to the ability to assign large sets of permissions at once.
This is achieved primarily through the use of roles, although object groups can be of some help here as well.
Roles are interpositioned between subjects and their rights regarding objects, and it is this positioning which enables the indirection.
The use of roles is quite simple, as the following two samples shall illustrate.

\subsubsection{Simple}
Our first example is of the most basic usage. We define a few roles in terms of their permissions or privileges over several individual objects (assumed to be previously defined), and then assign those roles variously to subjects as we wish.
\begin{lstlisting}
<roles>
    <role description="This is a general User role">
        <name>User</name>
        <permission description="Read rights for all Users on generic files">
            <type>Read</type>
            <target type="object">file1.txt</target>
            <target type="object">file2.txt</target>
            <target type="object">file3.txt</target>
        </permission>
        <permission description="Write rights for all Users for null device">
            <type>Write</type>
            <target type="object">/dev/null</target>
        </permission>
        <permission description="Append rights for all Users for generic files">
            <type>Append</type>
            <target type="object">file1.txt</target>
            <target type="object">file2.txt</target>
            <target type="object">file3.txt</target>
        </permission>
  </role>             <!-- End role 'User' -->
  <role description="This is a more powerful Admin role">
      <name>Admin</name>
      <permission description="Read rights for everything in User plus important files">
          <type>Read</type>
          <target type="object">file1.txt</target>
          <target type="object">file2.txt</target>
          <target type="object">file3.txt</target>
          <target type="object">special.txt</target>
          <target type="object">secret.txt</target>
      </permission>
      <permission description="Write rights for everything">
          <type>Write</type>
          <target type="object">file1.txt</target>
          <target type="object">file2.txt</target>
          <target type="object">file3.txt</target>
          <target type="object">special.txt</target>
          <target type="object">secret.txt</target>
          <target type="object">/dev/null</target>
      </permission>
      <permission description="Delete rights for all files"
          <type>Delete</type>
          <target type="object">file1.txt</target>
          <target type="object">file2.txt</target>
          <target type="object">file3.txt</target>
          <target type="object">special.txt</target>
          <target type="object">secret.txt</target>
      </permission>
  </role>             <!-- End role 'Admin' -->
</roles>
<subjects>
    <subject>
        <name>Alice</name>
        <role>Admin</role>
        <role>User</role>
    </subject>
    <subject>
        <name>Bob</name>
        <role>User</role>
    </subject>
    <subject>
        <name>Charlie</name>
        <role>User</role>
    </subject>
    <subject>
        <name>Diana</name>
    </subject>
    ...
</subjects>
\end{lstlisting}

This schema allows us to specify just once which objects are accessible by which roles. Then we assign a subject to zero or more roles (which include groups of permissions) rather than directly to permissions one at a time. So in the above example Alice, Bob, and Charlie have all the permissions specified by the role 'User', Alice also has the permissions given by 'Admin' (note that these may overlap), and Diana has been given no permissions.
This is by contrast to a capability-based or ACL-based system, for example, which might require that we explicitly link all subjects with all objects they can access, entailing a large amount of repeated effort.

\subsubsection{Advanced}
An even more effective way to use roles to provide indirection is by combining them with logical objects, or object groups. More details on how to represent object groups have been given above, as well as in \textbf{W5},
so here we will simply assume that \inlinecode{file1.txt}, \inlinecode{file2.txt}, and \inlinecode{file3.txt} have all been assigned the group 'Files'. We also suppose that \inlinecode{special.txt} and \inlinecode{secret.txt} belong to the group 'Important Files', and that the device \inlinecode{/dev/null} does not belong to any groups. Notice below how we are able to assign the same permissions as above with even fewer lines! \pagebreak
\begin{lstlisting}
<role description="This is a general User role">
    <name>User</name>
    <permission description="Read rights for all Users on files in group 'Files'">
        <type>Read</type>
        <target type="objectGroup">Files</target>
    </permission>
    <permission description="Write rights for all Users for null device">
        <type>Write</type>
        <target type="object">/dev/null</target>
    </permission>
    <permission description="Append rights for all Users for files in group 'Files'">
        <type>Append</type>
        <target type="objectGroup">Files</target>
    </permission>
</role>             <!-- End role 'User' -->
<role description="This is a more powerful Admin role">
  <name>Admin</name>
  <permission description="Read rights for 'Files' plus 'Important files'">
      <type>Read</type>
      <target type="objectGroup">Files</target>
      <target type="objectGroup">Important Files</target>
  </permission>
  <permission description="Write rights for everything">
      <type>Write</type>
      <target type="objectGroup">Files</target>
      <target type="objectGroup">Important Files</target>
      <target type="object">/dev/null</target>
  </permission>
  <permission description="Delete rights for all files"
      <type>Delete</type>
      <target type="objectGroup">Files</target>
      <target type="objectGroup">Important Files</target>
  </permission>
</role>             <!-- End role 'Admin' -->
\end{lstlisting}
Afterwards, roles can be given to users the same as before. See how much simpler it is to specify large groups of objects to be assigned? It is important to note useful properties when you are defining objects (see Object Groups in \textbf{W5} for more info). However, as with \inlinecode{/dev/null} above, objects without a group must still be included in a \inlinecode{<permission>} individually. Finally, role hierarchies and attribute inference make the process of assigning permissions even easier and more flexible -- see \textbf{W5} for further info on each of those as well.


\task{W4}
\subsection{Delegation}
Now we tackle delegations across entities. We will assume that the entity being delegated \textit{to} and the entity being delegated \textit{from} are distinct, since otherwise we have a case of role hierarchy (which \textit{can} be specified here, but should be placed in its own type of policy -- see \textbf{W5} for further details).
\paragraph{Note 1:} Do NOT attempt to delegate "in circles" or you run the risk of causing an endless loop, crashing the enforcement engine. Chains of trust are acceptable, but delegating authority for a role between two entities and then back again is not recommended.
\paragraph{Note 2:} All delegation of authority (i.e. 'importing' roles from another entity, so to speak) must take place \textit{within} the 'to' entity. This only makes sense -- an organization should not be able to give its members roles in another organization that it doesn't control. This provides for better support in distributed environments.

\subsubsection{Simple Delegation}
The basic form of delegation is from a role in one entity to the same role in another entity. This is easily accomplished as shown below, in the \inlinecode{Policies} section of the file. Suppose we have described two entities in our file, 'Work' and 'School', and we want all Work administrators to automatically be School administrators as well.

\begin{lstlisting}
...
<policies>
    ...
    <delegation>
        <if>Admin</if>
        <from>Work</from>
        <then>Admin</then>
        <to>School</to>
    </delegation>
</policies>
...
\end{lstlisting}
We use the conditional form of the policy statement to guide our design. Simply take the 'if-then' statement and describe both role and identity in each half of the implication, resulting in "If \{Entity\}.\{Role\} then \{Entity\}.\{Role\}."

\subsubsection{Cross-Role Delegation}
A more complex usage of delegation may take the form of giving authority over a role in one entity to a different role in another entity. It even involve chains of trust through multiple organizations, as in the following example. Suppose that there are three entities in the file: 'Gloogle' and two Gloogle departments 'Research' and 'Games'. Suppose also that we want the following relationships between roles to hold (using the format \{Entity\}.\{Role\} implies \{Entity\}.\{Role\}):
\begin{itemize}\tightlist
  \item Gloogle.Admin $\rightarrow$ Research.Admin
  \item Games.Manager $\rightarrow$ Gloogle.Admin
  \item Research.Scientist $\rightarrow$ Gloogle.User
  \item Games.Player $\rightarrow$ Gloogle.User
\end{itemize}
Then we may represent these in the following way:
\begin{lstlisting}
<entity name="Research">
    ...
    <policies>
        <delegation>
            <if>Admin</if>
            <from>Gloogle</from>
            <then>Admin</then>
            <to>Research</to>
        </delegation>
    </policies>
</entity>
<entity name="Gloogle">
    ...
    <policies>
        <delegation>
            <if>Manager</if>
            <from>Games</from>
            <then>Admin</then>
            <to>Gloogle</to>
        </delegation>
        <delegation>
            <if>Scientist</if>
            <from>Research</from>
            <then>User</then>
            <to>Gloogle</to>
        </delegation>
        <delegation>
            <if>Player</if>
            <from>Games</from>
            <then>User</then>
            <to>Gloogle</to>
        </delegation>
    </policies>
</entity>
\end{lstlisting}
Note that the \inlinecode{<to>} field always matches the entity within which it is described.


\task{W5}
\subsection{Logical Objects}
Here we explore a very useful feature contributed from the $\RT_2$ variant, namely logical objects or object groups. This feature is actually made use of in the section on indirection (\textbf{W3}), but here we examine it more closely in the form of two different examples. \par

\subsubsection{Simple}
Object groups are easy to use, and are in fact defined in the \inlinecode{<data>} section of an entity. The simplest usage would be to assign every object to just one group, then referring to multiple groups later on (say, in \inlinecode{<roles>}) if a union of groups is desired. This is represented simply by first defining the object groups and then, when describing objects, by adding the sub-element \inlinecode{<group>}:
\begin{lstlisting}
<objects>
    <objectGroup description="This group is for regular old files">
        <name>Files</name>
    </objectGroup>
    <objectGroup description="This group is for special files">
        <name>Special</name>
    </objectGroup>
    <objectGroup description="This group is for devices">
        <name>Devices</name>
    </objectGroup>
    <object>
        <name>file1</name>
        <group>Files</group>
    </object>
    <object>
        <name>spec2</name>
        <group>Special</group>
    </object>
    <object>
        <name>dev3</name>
        <group>Devices</group>
    </object>
    ...
    <object description="This object has no group">
        <name>strangeObject.computer</name>
    </object>
</objects>
\end{lstlisting}
Note that not every object must have a group, as in the last object above. Later, we may use object group names to assign permissons to the entire group instead of individually (see section \textbf{W1} for details on \inlinecode{<role>} usage).

\subsubsection{Multiple Groups}
The more advanced and powerful way of utilizing logical objects is by assigning multiple groups to every object.
For example, suppose you want to be able to refer to every object in an entity, as well as certain subsets.
This is possible by adding as many groups -- and hence assigning as many groups to an object -- as you would like.
\begin{lstlisting}
<objects>
    <objectGroup description="This group is for everything">
        <name>All</name>
    </objectGroup>
    <objectGroup description="This group is for files">
        <name>Files</name>
    </objectGroup>
    <objectGroup description="This group is for all objects related to school">
        <name>School</name>
    </objectGroup>
    <object>
        <name>file1.home</name>
        <group>Files</group>
        <group>All</group>
    </object>
    <object>
        <name>file2.school</name>
        <group>School</group>
        <group>Files</group>
        <group>All</group>
    </object>
    <object>
        <name>dev3</name>
        <group>School</group>
        <group>All</group>
    </object>
    ...
</objects>
\end{lstlisting}
Now we have great flexibility and power when selecting objects. If we choose the group 'All', then we can specify every object (so long as they all are assigned to that group, as above). If we choose the 'Files' group, then we can get \inlinecode{file1} and \inlinecode{file2} without selecting \inlinecode{dev3}, and if we choose 'School' then we can get all school-related objects whether or not they are files.
The utility of this schema is immediately apparent. For more details on usage of logical objects when assigning them to roles, refer to the roles section in \textbf{W1}.

\subsection{Role Hierarchies}
This property was first introduced in the policies section of \textbf{W1}, and is relatively straightforward in all its variant.

\subsubsection{Simple}
At its simplest, it comprises an implication from one role to another, which can also be considered a textit{delegation} of authority from one (the dominating role) role to another (the containing role).
\begin{lstlisting}
<policies>
    <hierarchy>
        <if>Admin</if>
        <then>User</then>
    </hierarchy>
</policies>
\end{lstlisting}
This policy automatically makes every Admin subject a User subject as well, adding all User permissions to the Admin role in some sense. Thus there is no need to specify on definition that a given subject is both an Admin \textit{and} a User; simply indicate the Admin role and the subject will be given User privileges by default. On large-scale systems this single rule may replace a great deal of typing.

\subsubsection{Hierarchy Chains}
A more interesting variant comprises multiple hierarchical inferences within an entity, resulting in a chain of internal delegation. This allows, as with logical objects, a more flexible and powerful specification of roles.
\begin{lstlisting}
<policies>
    <hierarchy>
        <if>Admin</if>
        <then>User</then>
    </hierarchy>
    <hierarchy>
        <if>Admin</if>
        <then>Manager</then>
    </hierarchy>
    <hierarchy>
        <if>Manager</if>
        <then>User</then>
    </hierarchy>
</policies>
\end{lstlisting}
Here we've defined a multi-level hierarchy that includes all administrators as managers and users, and includes all managers as users.
This feature can be modified to indefinite complexity, depending on the needs of the organization and the number/relationship of the roles therein. \\

\subsection{Attribute Inference}
Attribute inference works in conjunction with logical objects to allow more powerful and flexible specification of objects, removing much of the need to assign them to multiple groups. It is a sort of hierarchy for object groups.
Attribute inference was demonstrated in \textbf{W1}, but here are another couple of examples to show. Suppose for the sake of these examples that we have defined the object groups 'All', 'Files', 'Devices', 'Special', and 'Tools'.

\subsubsection{Simple}
The most basic form of inference is simply an inference of group membership, and can be implemented like so.
\begin{lstlisting}
<inference>
    <if>Files</if>
    <then>All</then>
</inference>
<inference>
    <if>Devices</if>
    <then>All</then>
</inference>
<inference>
    <if>Devices</if>
    <then>Tools</then>
</inference>
\end{lstlisting}
Here we indicate that any objects in the 'Files' or 'Devices' groups should also be in the 'All' group. We also assign any objects in the 'Devices' group to the 'Tools' group as well. These rules prevent us from having to add as many \inlinecode{<group>} sub-elements to the objects as we define them.

\subsubsection{Group Hierarchy}
A more complex example might involve multiple levels of inference to fully establish all relationships.
\begin{lstlisting}
<inference>
    <if>Files</if>
    <then>All</then>
</inference>
<inference>
    <if>Tools</if>
    <then>All</then>
</inference>
<inference>
    <if>Devices</if>
    <then>Tools</then>
</inference>
<inference>
    <if>Special</if>
    <then>Files</then>
</inference>
\end{lstlisting}
In this way we've established two divisions of the 'All' group: one that contains the 'Files' group which in turn contains 'Special'; and another that contains 'Tools', which itself contains 'Devices'. In this way any objects assigned to 'Special' or 'Devices' will also end up in 'All' without ever being explicitly linked to it!

\task{C6}
See the accompanying program \inlinecode{timeparse.py} for the full details of my timing program. Each policy file (1-4) was based on a different scenario: home, small business, several medium-sized entities, and many entities. The results are given below.

\task{W7}
Filler.

\pagebreak

\printbibliography[heading=bibintoc]

\end{document}
